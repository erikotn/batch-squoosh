<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BatchSquoosh - Bulk Image Optimizer</title>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- JSZip for batch downloading -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    
    <!-- FileSaver for saving the zip -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

    <style>
        body { background-color: #0f172a; color: #e2e8f0; font-family: 'Inter', sans-serif; }
        .custom-scrollbar::-webkit-scrollbar { width: 8px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #1e293b; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #64748b; }
        
        /* Spinner Animation */
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .spinner { animation: spin 1s linear infinite; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useCallback, useRef } = React;

        // --- Icons (Inline SVG for zero dependencies) ---
        const IconUpload = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>;
        const IconDownload = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>;
        const IconTrash = () => <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/></svg>;
        const IconImage = () => <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/></svg>;
        const IconSettings = () => <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.09a2 2 0 0 1-1-1.74v-.47a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"/><circle cx="12" cy="12" r="3"/></svg>;
        const IconCheck = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="text-green-400"><polyline points="20 6 9 17 4 12"/></svg>;
        const IconLoader = () => <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="spinner text-blue-400"><path d="M21 12a9 9 0 1 1-6.219-8.56"/></svg>;

        // --- Helper: Format Bytes ---
        const formatBytes = (bytes, decimals = 2) => {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const dm = decimals < 0 ? 0 : decimals;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        };

        // --- Main App Component ---
        const App = () => {
            const [files, setFiles] = useState([]);
            const [isDragging, setIsDragging] = useState(false);
            const [isProcessing, setIsProcessing] = useState(false);
            const [globalSettings, setGlobalSettings] = useState({
                quality: 0.8,
                format: 'image/jpeg',
                maxWidth: 1920,
            });

            // --- Core Image Compression Logic (Canvas API) ---
            const compressImage = async (file, settings) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = (event) => {
                        const img = new Image();
                        img.src = event.target.result;
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            let width = img.width;
                            let height = img.height;

                            // Resize logic (maintain aspect ratio)
                            if (width > settings.maxWidth) {
                                height = Math.round((height * settings.maxWidth) / width);
                                width = settings.maxWidth;
                            }

                            canvas.width = width;
                            canvas.height = height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, width, height);

                            canvas.toBlob(
                                (blob) => {
                                    if (!blob) {
                                        reject(new Error('Compression failed'));
                                        return;
                                    }
                                    resolve({
                                        original: file,
                                        compressed: blob,
                                        previewUrl: URL.createObjectURL(blob), // Create URL for preview
                                        originalSize: file.size,
                                        compressedSize: blob.size,
                                        width,
                                        height,
                                        id: Math.random().toString(36).substr(2, 9),
                                        status: 'done'
                                    });
                                },
                                settings.format,
                                settings.quality
                            );
                        };
                        img.onerror = (err) => reject(err);
                    };
                    reader.onerror = (err) => reject(err);
                });
            };

            // --- Handlers ---
            const handleDrop = useCallback(async (e) => {
                e.preventDefault();
                setIsDragging(false);
                
                const droppedFiles = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
                if (droppedFiles.length === 0) return;

                addFiles(droppedFiles);
            }, [globalSettings]); // Re-create if settings change (though we pass current settings explicitly)

            const handleFileSelect = (e) => {
                const selectedFiles = Array.from(e.target.files);
                if (selectedFiles.length === 0) return;
                addFiles(selectedFiles);
            };

            const addFiles = async (newFiles) => {
                setIsProcessing(true);
                
                // Create placeholders first for immediate UI feedback
                const placeholders = newFiles.map(f => ({
                    id: Math.random().toString(36).substr(2, 9),
                    original: f,
                    status: 'processing',
                    originalSize: f.size
                }));

                setFiles(prev => [...prev, ...placeholders]);

                // Process sequentially to not freeze UI too badly on low-end devices
                const processedResults = [];
                for (let file of newFiles) {
                    try {
                        const result = await compressImage(file, globalSettings);
                        processedResults.push(result);
                    } catch (error) {
                        console.error("Error compressing", file.name, error);
                        // Push an error state if needed, or just keep original
                    }
                }

                // Replace placeholders with real data
                setFiles(prev => {
                    const updated = [...prev];
                    processedResults.forEach(res => {
                        const idx = updated.findIndex(f => f.original.name === res.original.name && f.status === 'processing');
                        if (idx !== -1) updated[idx] = res;
                    });
                    return updated;
                });
                
                setIsProcessing(false);
            };

            // Re-process all images when settings change
            // Debounced slightly to prevent crazy loops if slider is dragged fast
            useEffect(() => {
                const timeoutId = setTimeout(async () => {
                    if (files.length === 0) return;
                    
                    // Only re-process if we actually have files
                    setIsProcessing(true);
                    const newFiles = await Promise.all(files.map(async (f) => {
                        // Always re-compress from original source
                        return await compressImage(f.original, globalSettings);
                    }));
                    setFiles(newFiles);
                    setIsProcessing(false);
                }, 500);

                return () => clearTimeout(timeoutId);
            }, [globalSettings.quality, globalSettings.format, globalSettings.maxWidth]);

            const removeFile = (id) => {
                setFiles(files.filter(f => f.id !== id));
            };

            const downloadAll = async () => {
                const zip = new JSZip();
                const folder = zip.folder("optimized_images");
                
                files.forEach(f => {
                    let ext = globalSettings.format.split('/')[1];
                    if (ext === 'jpeg') ext = 'jpg';
                    const nameParts = f.original.name.split('.');
                    nameParts.pop(); // remove old extension
                    const newName = `${nameParts.join('.')}_min.${ext}`;
                    folder.file(newName, f.compressed);
                });

                const content = await zip.generateAsync({ type: "blob" });
                saveAs(content, "batch_optimized_images.zip");
            };

            // Calculate total stats
            const totalOriginal = files.reduce((acc, f) => acc + (f.originalSize || 0), 0);
            const totalCompressed = files.reduce((acc, f) => acc + (f.compressedSize || 0), 0);
            const totalSavings = totalOriginal > 0 ? ((totalOriginal - totalCompressed) / totalOriginal * 100).toFixed(1) : 0;

            return (
                <div className="min-h-screen flex flex-col items-center py-10 px-4 md:px-10">
                    
                    {/* Header */}
                    <div className="text-center mb-8">
                        <h1 className="text-4xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-pink-500 to-violet-500 mb-2">
                            BatchSquoosh
                        </h1>
                        <p className="text-slate-400">Secure, client-side batch image optimization.</p>
                    </div>

                    {/* Main Interface Grid */}
                    <div className="w-full max-w-6xl grid grid-cols-1 lg:grid-cols-12 gap-6">
                        
                        {/* LEFT: Controls & Stats */}
                        <div className="lg:col-span-4 space-y-6">
                            
                            {/* Settings Panel */}
                            <div className="bg-slate-800 p-6 rounded-2xl shadow-xl border border-slate-700">
                                <div className="flex items-center gap-2 mb-4 text-slate-200 font-semibold">
                                    <IconSettings /> Global Settings
                                </div>

                                <div className="space-y-4">
                                    {/* Format */}
                                    <div>
                                        <label className="block text-xs uppercase tracking-wide text-slate-500 mb-1">Output Format</label>
                                        <div className="grid grid-cols-3 gap-2">
                                            {['image/jpeg', 'image/png', 'image/webp'].map(fmt => (
                                                <button 
                                                    key={fmt}
                                                    onClick={() => setGlobalSettings(s => ({...s, format: fmt}))}
                                                    className={`text-sm py-2 rounded-lg border transition-colors ${
                                                        globalSettings.format === fmt 
                                                        ? 'bg-violet-600 border-violet-500 text-white' 
                                                        : 'bg-slate-700 border-slate-600 text-slate-300 hover:bg-slate-600'
                                                    }`}
                                                >
                                                    {fmt.split('/')[1].toUpperCase()}
                                                </button>
                                            ))}
                                        </div>
                                    </div>

                                    {/* Quality */}
                                    <div>
                                        <div className="flex justify-between mb-1">
                                            <label className="text-xs uppercase tracking-wide text-slate-500">Quality</label>
                                            <span className="text-xs text-violet-400 font-mono">{Math.round(globalSettings.quality * 100)}%</span>
                                        </div>
                                        <input 
                                            type="range" 
                                            min="0.1" 
                                            max="1" 
                                            step="0.05" 
                                            value={globalSettings.quality}
                                            onChange={(e) => setGlobalSettings(s => ({...s, quality: parseFloat(e.target.value)}))}
                                            className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-violet-500"
                                        />
                                    </div>

                                    {/* Max Width */}
                                    <div>
                                        <div className="flex justify-between mb-1">
                                            <label className="text-xs uppercase tracking-wide text-slate-500">Max Width (px)</label>
                                            <span className="text-xs text-violet-400 font-mono">{globalSettings.maxWidth}px</span>
                                        </div>
                                        <input 
                                            type="range" 
                                            min="400" 
                                            max="3840" 
                                            step="100" 
                                            value={globalSettings.maxWidth}
                                            onChange={(e) => setGlobalSettings(s => ({...s, maxWidth: parseInt(e.target.value)}))}
                                            className="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-violet-500"
                                        />
                                    </div>
                                </div>
                            </div>

                            {/* Summary Stats */}
                            {files.length > 0 && (
                                <div className="bg-slate-800 p-6 rounded-2xl shadow-xl border border-slate-700">
                                    <div className="flex justify-between items-end mb-4">
                                        <div>
                                            <p className="text-xs text-slate-500 uppercase">Original</p>
                                            <p className="text-lg font-mono text-slate-300">{formatBytes(totalOriginal)}</p>
                                        </div>
                                        <div className="text-right">
                                            <p className="text-xs text-slate-500 uppercase">Compressed</p>
                                            <p className="text-lg font-mono text-green-400">{formatBytes(totalCompressed)}</p>
                                        </div>
                                    </div>
                                    <div className="bg-slate-700 rounded-full h-4 w-full overflow-hidden relative">
                                        <div 
                                            className="absolute top-0 left-0 h-full bg-gradient-to-r from-green-500 to-emerald-400 transition-all duration-500"
                                            style={{ width: `${100 - totalSavings}%` }}
                                        ></div>
                                    </div>
                                    <p className="text-center mt-2 text-sm text-green-400 font-bold">
                                        Saved {totalSavings}%
                                    </p>

                                    <button 
                                        onClick={downloadAll}
                                        className="w-full mt-4 bg-white text-slate-900 font-bold py-3 rounded-xl hover:bg-slate-200 transition-colors flex items-center justify-center gap-2"
                                    >
                                        <IconDownload /> Download All as ZIP
                                    </button>
                                </div>
                            )}
                        </div>

                        {/* RIGHT: Drop Zone & List */}
                        <div className="lg:col-span-8 flex flex-col h-[calc(100vh-200px)] min-h-[500px]">
                            
                            {/* Drop Zone */}
                            <div 
                                onDragOver={(e) => { e.preventDefault(); setIsDragging(true); }}
                                onDragLeave={() => setIsDragging(false)}
                                onDrop={handleDrop}
                                className={`relative flex-shrink-0 mb-6 border-2 border-dashed rounded-2xl p-8 transition-all duration-200 flex flex-col items-center justify-center text-center cursor-pointer group
                                    ${isDragging ? 'border-violet-500 bg-violet-500/10' : 'border-slate-600 hover:border-violet-400 hover:bg-slate-800'}`}
                            >
                                <input 
                                    type="file" 
                                    multiple 
                                    accept="image/*"
                                    onChange={handleFileSelect}
                                    className="absolute inset-0 w-full h-full opacity-0 cursor-pointer"
                                />
                                <div className="bg-slate-700 p-3 rounded-full mb-3 text-violet-400 group-hover:scale-110 transition-transform">
                                    <IconUpload />
                                </div>
                                <h3 className="text-lg font-semibold text-slate-200">Drag & Drop images here</h3>
                                <p className="text-sm text-slate-500">or click to browse</p>
                            </div>

                            {/* File List */}
                            <div className="flex-1 overflow-y-auto custom-scrollbar bg-slate-900/50 rounded-2xl border border-slate-800 p-4">
                                {files.length === 0 ? (
                                    <div className="h-full flex flex-col items-center justify-center text-slate-600 opacity-50">
                                        <IconImage />
                                        <p className="mt-2 text-sm">No images added yet</p>
                                    </div>
                                ) : (
                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                                        {files.map(file => (
                                            <div key={file.id} className="bg-slate-800 rounded-xl p-3 flex gap-4 items-center border border-slate-700 relative group animate-fade-in">
                                                
                                                {/* Preview */}
                                                <div className="w-20 h-20 flex-shrink-0 bg-slate-900 rounded-lg overflow-hidden border border-slate-600 relative">
                                                    {file.status === 'processing' ? (
                                                        <div className="w-full h-full flex items-center justify-center"><IconLoader /></div>
                                                    ) : (
                                                        <img src={file.previewUrl} alt="preview" className="w-full h-full object-cover" />
                                                    )}
                                                </div>

                                                {/* Info */}
                                                <div className="flex-1 min-w-0">
                                                    <p className="text-sm font-medium text-slate-200 truncate pr-6">{file.original.name}</p>
                                                    
                                                    {file.status === 'done' && (
                                                        <div className="mt-1 space-y-1">
                                                            <div className="flex items-center gap-2 text-xs">
                                                                <span className="text-slate-500 line-through">{formatBytes(file.originalSize)}</span>
                                                                <span className="text-slate-400">â†’</span>
                                                                <span className="text-green-400 font-bold">{formatBytes(file.compressedSize)}</span>
                                                            </div>
                                                            <div className="inline-flex items-center px-1.5 py-0.5 rounded text-[10px] bg-slate-700 text-slate-400 border border-slate-600">
                                                                {file.width} x {file.height}
                                                            </div>
                                                        </div>
                                                    )}
                                                </div>

                                                {/* Actions */}
                                                <button 
                                                    onClick={() => removeFile(file.id)}
                                                    className="absolute top-2 right-2 p-1.5 text-slate-500 hover:text-red-400 hover:bg-slate-700 rounded-lg transition-colors"
                                                >
                                                    <IconTrash />
                                                </button>

                                                {file.status === 'done' && (
                                                    <div className="absolute bottom-2 right-2 bg-green-500/10 p-1 rounded-full">
                                                        <IconCheck />
                                                    </div>
                                                )}
                                            </div>
                                        ))}
                                    </div>
                                )}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
